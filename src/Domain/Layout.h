//AUTOGENERATED BY genLayout.py
  
#ifndef __DOMAIN_LAYOUT_H__
#define __DOMAIN_LAYOUT_H__

#include <Domain/Index.h>


    struct PERM_I {};
    struct PERM_IJ {};
    struct PERM_JI {};
    struct PERM_IJK {};
    struct PERM_IKJ {};
    struct PERM_JIK {};
    struct PERM_JKI {};
    struct PERM_KIJ {};
    struct PERM_KJI {};
    struct PERM_IJKL {};
    struct PERM_IJLK {};
    struct PERM_IKJL {};
    struct PERM_IKLJ {};
    struct PERM_ILJK {};
    struct PERM_ILKJ {};
    struct PERM_JIKL {};
    struct PERM_JILK {};
    struct PERM_JKIL {};
    struct PERM_JKLI {};
    struct PERM_JLIK {};
    struct PERM_JLKI {};
    struct PERM_KIJL {};
    struct PERM_KILJ {};
    struct PERM_KJIL {};
    struct PERM_KJLI {};
    struct PERM_KLIJ {};
    struct PERM_KLJI {};
    struct PERM_LIJK {};
    struct PERM_LIKJ {};
    struct PERM_LJIK {};
    struct PERM_LJKI {};
    struct PERM_LKIJ {};
    struct PERM_LKJI {};

    template<typename Perm, typename IdxLin=int, typename IdxI=int>
    struct Layout1d {};

    template<typename Perm, typename IdxLin=int, typename IdxI=int, typename IdxJ=int>
    struct Layout2d {};

    template<typename Perm, typename IdxLin=int, typename IdxI=int, typename IdxJ=int, typename IdxK=int>
    struct Layout3d {};

    template<typename Perm, typename IdxLin=int, typename IdxI=int, typename IdxJ=int, typename IdxK=int, typename IdxL=int>
    struct Layout4d {};


/******************************************************************
 *  Implementation for Layout1D
 ******************************************************************/

    template<typename IdxLin, typename IdxI>
    struct Layout1d<PERM_I, IdxLin, IdxI> {
      typedef PERM_I Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;

      int const size_i;

      int const stride_i;

      inline Layout1d(int ni):
        size_i(ni), stride_i(1)
      {}

      inline IdxLin operator()(IdxI i) const {
        return convertIndex<IdxLin>(convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i) const {
        int linear = convertIndex<int>(lin);
        i = IdxI(linear);
      }
    };



/******************************************************************
 *  Implementation for Layout2D
 ******************************************************************/

    template<typename IdxLin, typename IdxI, typename IdxJ>
    struct Layout2d<PERM_IJ, IdxLin, IdxI, IdxJ> {
      typedef PERM_IJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;

      int const size_i;
      int const size_j;

      int const stride_i;
      int const stride_j;

      inline Layout2d(int ni, int nj):
        size_i(ni), size_j(nj), stride_i(nj), stride_j(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_j);
        i = IdxI(_i);
        linear -= _i*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ>
    struct Layout2d<PERM_JI, IdxLin, IdxI, IdxJ> {
      typedef PERM_JI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;

      int const size_i;
      int const size_j;

      int const stride_i;
      int const stride_j;

      inline Layout2d(int ni, int nj):
        size_i(ni), size_j(nj), stride_i(1), stride_j(ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_i);
        j = IdxJ(_j);
        linear -= _j*(size_i);
        i = IdxI(linear);
      }
    };



/******************************************************************
 *  Implementation for Layout3D
 ******************************************************************/

    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_IJK, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_IJK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(nj*nk), stride_j(nk), stride_k(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(j)*stride_j + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_j*size_k);
        i = IdxI(_i);
        linear -= _i*(size_j*size_k);
        int _j = linear / (size_k);
        j = IdxJ(_j);
        linear -= _j*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_IKJ, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_IKJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(nk*nj), stride_j(1), stride_k(nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(k)*stride_k + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_k*size_j);
        i = IdxI(_i);
        linear -= _i*(size_k*size_j);
        int _k = linear / (size_j);
        k = IdxK(_k);
        linear -= _k*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_JIK, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_JIK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(nk), stride_j(ni*nk), stride_k(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(i)*stride_i + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_i*size_k);
        j = IdxJ(_j);
        linear -= _j*(size_i*size_k);
        int _i = linear / (size_k);
        i = IdxI(_i);
        linear -= _i*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_JKI, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_JKI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(nk*ni), stride_k(ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(k)*stride_k + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_k*size_i);
        j = IdxJ(_j);
        linear -= _j*(size_k*size_i);
        int _k = linear / (size_i);
        k = IdxK(_k);
        linear -= _k*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_KIJ, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_KIJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(nj), stride_j(1), stride_k(ni*nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(i)*stride_i + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_i*size_j);
        k = IdxK(_k);
        linear -= _k*(size_i*size_j);
        int _i = linear / (size_j);
        i = IdxI(_i);
        linear -= _i*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK>
    struct Layout3d<PERM_KJI, IdxLin, IdxI, IdxJ, IdxK> {
      typedef PERM_KJI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      int const size_i;
      int const size_j;
      int const size_k;

      int const stride_i;
      int const stride_j;
      int const stride_k;

      inline Layout3d(int ni, int nj, int nk):
        size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(ni), stride_k(nj*ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(j)*stride_j + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_j*size_i);
        k = IdxK(_k);
        linear -= _k*(size_j*size_i);
        int _j = linear / (size_i);
        j = IdxJ(_j);
        linear -= _j*(size_i);
        i = IdxI(linear);
      }
    };



/******************************************************************
 *  Implementation for Layout4D
 ******************************************************************/

    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_IJKL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_IJKL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(j)*stride_j + convertIndex<int>(k)*stride_k + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_j*size_k*size_l);
        i = IdxI(_i);
        linear -= _i*(size_j*size_k*size_l);
        int _j = linear / (size_k*size_l);
        j = IdxJ(_j);
        linear -= _j*(size_k*size_l);
        int _k = linear / (size_l);
        k = IdxK(_k);
        linear -= _k*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_IJLK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_IJLK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(j)*stride_j + convertIndex<int>(l)*stride_l + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_j*size_l*size_k);
        i = IdxI(_i);
        linear -= _i*(size_j*size_l*size_k);
        int _j = linear / (size_l*size_k);
        j = IdxJ(_j);
        linear -= _j*(size_l*size_k);
        int _l = linear / (size_k);
        l = IdxL(_l);
        linear -= _l*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_IKJL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_IKJL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(k)*stride_k + convertIndex<int>(j)*stride_j + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_k*size_j*size_l);
        i = IdxI(_i);
        linear -= _i*(size_k*size_j*size_l);
        int _k = linear / (size_j*size_l);
        k = IdxK(_k);
        linear -= _k*(size_j*size_l);
        int _j = linear / (size_l);
        j = IdxJ(_j);
        linear -= _j*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_IKLJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_IKLJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(k)*stride_k + convertIndex<int>(l)*stride_l + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_k*size_l*size_j);
        i = IdxI(_i);
        linear -= _i*(size_k*size_l*size_j);
        int _k = linear / (size_l*size_j);
        k = IdxK(_k);
        linear -= _k*(size_l*size_j);
        int _l = linear / (size_j);
        l = IdxL(_l);
        linear -= _l*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_ILJK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_ILJK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(l)*stride_l + convertIndex<int>(j)*stride_j + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_l*size_j*size_k);
        i = IdxI(_i);
        linear -= _i*(size_l*size_j*size_k);
        int _l = linear / (size_j*size_k);
        l = IdxL(_l);
        linear -= _l*(size_j*size_k);
        int _j = linear / (size_k);
        j = IdxJ(_j);
        linear -= _j*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_ILKJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_ILKJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(i)*stride_i + convertIndex<int>(l)*stride_l + convertIndex<int>(k)*stride_k + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _i = linear / (size_l*size_k*size_j);
        i = IdxI(_i);
        linear -= _i*(size_l*size_k*size_j);
        int _l = linear / (size_k*size_j);
        l = IdxL(_l);
        linear -= _l*(size_k*size_j);
        int _k = linear / (size_j);
        k = IdxK(_k);
        linear -= _k*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JIKL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JIKL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(i)*stride_i + convertIndex<int>(k)*stride_k + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_i*size_k*size_l);
        j = IdxJ(_j);
        linear -= _j*(size_i*size_k*size_l);
        int _i = linear / (size_k*size_l);
        i = IdxI(_i);
        linear -= _i*(size_k*size_l);
        int _k = linear / (size_l);
        k = IdxK(_k);
        linear -= _k*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JILK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JILK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(i)*stride_i + convertIndex<int>(l)*stride_l + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_i*size_l*size_k);
        j = IdxJ(_j);
        linear -= _j*(size_i*size_l*size_k);
        int _i = linear / (size_l*size_k);
        i = IdxI(_i);
        linear -= _i*(size_l*size_k);
        int _l = linear / (size_k);
        l = IdxL(_l);
        linear -= _l*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JKIL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JKIL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(k)*stride_k + convertIndex<int>(i)*stride_i + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_k*size_i*size_l);
        j = IdxJ(_j);
        linear -= _j*(size_k*size_i*size_l);
        int _k = linear / (size_i*size_l);
        k = IdxK(_k);
        linear -= _k*(size_i*size_l);
        int _i = linear / (size_l);
        i = IdxI(_i);
        linear -= _i*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JKLI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JKLI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(k)*stride_k + convertIndex<int>(l)*stride_l + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_k*size_l*size_i);
        j = IdxJ(_j);
        linear -= _j*(size_k*size_l*size_i);
        int _k = linear / (size_l*size_i);
        k = IdxK(_k);
        linear -= _k*(size_l*size_i);
        int _l = linear / (size_i);
        l = IdxL(_l);
        linear -= _l*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JLIK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JLIK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(l)*stride_l + convertIndex<int>(i)*stride_i + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_l*size_i*size_k);
        j = IdxJ(_j);
        linear -= _j*(size_l*size_i*size_k);
        int _l = linear / (size_i*size_k);
        l = IdxL(_l);
        linear -= _l*(size_i*size_k);
        int _i = linear / (size_k);
        i = IdxI(_i);
        linear -= _i*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_JLKI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_JLKI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(j)*stride_j + convertIndex<int>(l)*stride_l + convertIndex<int>(k)*stride_k + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _j = linear / (size_l*size_k*size_i);
        j = IdxJ(_j);
        linear -= _j*(size_l*size_k*size_i);
        int _l = linear / (size_k*size_i);
        l = IdxL(_l);
        linear -= _l*(size_k*size_i);
        int _k = linear / (size_i);
        k = IdxK(_k);
        linear -= _k*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KIJL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KIJL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(i)*stride_i + convertIndex<int>(j)*stride_j + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_i*size_j*size_l);
        k = IdxK(_k);
        linear -= _k*(size_i*size_j*size_l);
        int _i = linear / (size_j*size_l);
        i = IdxI(_i);
        linear -= _i*(size_j*size_l);
        int _j = linear / (size_l);
        j = IdxJ(_j);
        linear -= _j*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KILJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KILJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(i)*stride_i + convertIndex<int>(l)*stride_l + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_i*size_l*size_j);
        k = IdxK(_k);
        linear -= _k*(size_i*size_l*size_j);
        int _i = linear / (size_l*size_j);
        i = IdxI(_i);
        linear -= _i*(size_l*size_j);
        int _l = linear / (size_j);
        l = IdxL(_l);
        linear -= _l*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KJIL, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KJIL Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(j)*stride_j + convertIndex<int>(i)*stride_i + convertIndex<int>(l));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_j*size_i*size_l);
        k = IdxK(_k);
        linear -= _k*(size_j*size_i*size_l);
        int _j = linear / (size_i*size_l);
        j = IdxJ(_j);
        linear -= _j*(size_i*size_l);
        int _i = linear / (size_l);
        i = IdxI(_i);
        linear -= _i*(size_l);
        l = IdxL(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KJLI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KJLI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(j)*stride_j + convertIndex<int>(l)*stride_l + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_j*size_l*size_i);
        k = IdxK(_k);
        linear -= _k*(size_j*size_l*size_i);
        int _j = linear / (size_l*size_i);
        j = IdxJ(_j);
        linear -= _j*(size_l*size_i);
        int _l = linear / (size_i);
        l = IdxL(_l);
        linear -= _l*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KLIJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KLIJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(l)*stride_l + convertIndex<int>(i)*stride_i + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_l*size_i*size_j);
        k = IdxK(_k);
        linear -= _k*(size_l*size_i*size_j);
        int _l = linear / (size_i*size_j);
        l = IdxL(_l);
        linear -= _l*(size_i*size_j);
        int _i = linear / (size_j);
        i = IdxI(_i);
        linear -= _i*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_KLJI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_KLJI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(k)*stride_k + convertIndex<int>(l)*stride_l + convertIndex<int>(j)*stride_j + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _k = linear / (size_l*size_j*size_i);
        k = IdxK(_k);
        linear -= _k*(size_l*size_j*size_i);
        int _l = linear / (size_j*size_i);
        l = IdxL(_l);
        linear -= _l*(size_j*size_i);
        int _j = linear / (size_i);
        j = IdxJ(_j);
        linear -= _j*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LIJK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LIJK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(i)*stride_i + convertIndex<int>(j)*stride_j + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_i*size_j*size_k);
        l = IdxL(_l);
        linear -= _l*(size_i*size_j*size_k);
        int _i = linear / (size_j*size_k);
        i = IdxI(_i);
        linear -= _i*(size_j*size_k);
        int _j = linear / (size_k);
        j = IdxJ(_j);
        linear -= _j*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LIKJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LIKJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(i)*stride_i + convertIndex<int>(k)*stride_k + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_i*size_k*size_j);
        l = IdxL(_l);
        linear -= _l*(size_i*size_k*size_j);
        int _i = linear / (size_k*size_j);
        i = IdxI(_i);
        linear -= _i*(size_k*size_j);
        int _k = linear / (size_j);
        k = IdxK(_k);
        linear -= _k*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LJIK, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LJIK Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(j)*stride_j + convertIndex<int>(i)*stride_i + convertIndex<int>(k));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_j*size_i*size_k);
        l = IdxL(_l);
        linear -= _l*(size_j*size_i*size_k);
        int _j = linear / (size_i*size_k);
        j = IdxJ(_j);
        linear -= _j*(size_i*size_k);
        int _i = linear / (size_k);
        i = IdxI(_i);
        linear -= _i*(size_k);
        k = IdxK(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LJKI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LJKI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(j)*stride_j + convertIndex<int>(k)*stride_k + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_j*size_k*size_i);
        l = IdxL(_l);
        linear -= _l*(size_j*size_k*size_i);
        int _j = linear / (size_k*size_i);
        j = IdxJ(_j);
        linear -= _j*(size_k*size_i);
        int _k = linear / (size_i);
        k = IdxK(_k);
        linear -= _k*(size_i);
        i = IdxI(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LKIJ, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LKIJ Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(k)*stride_k + convertIndex<int>(i)*stride_i + convertIndex<int>(j));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_k*size_i*size_j);
        l = IdxL(_l);
        linear -= _l*(size_k*size_i*size_j);
        int _k = linear / (size_i*size_j);
        k = IdxK(_k);
        linear -= _k*(size_i*size_j);
        int _i = linear / (size_j);
        i = IdxI(_i);
        linear -= _i*(size_j);
        j = IdxJ(linear);
      }
    };


    template<typename IdxLin, typename IdxI, typename IdxJ, typename IdxK, typename IdxL>
    struct Layout4d<PERM_LKJI, IdxLin, IdxI, IdxJ, IdxK, IdxL> {
      typedef PERM_LKJI Permutation;
      typedef IdxLin IndexLinear;
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;
      typedef IdxL IndexL;

      int const size_i;
      int const size_j;
      int const size_k;
      int const size_l;

      int const stride_i;
      int const stride_j;
      int const stride_k;
      int const stride_l;

      inline Layout4d(int ni, int nj, int nk, int nl):
        size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni)
      {}

      inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
        return convertIndex<IdxLin>(convertIndex<int>(l)*stride_l + convertIndex<int>(k)*stride_k + convertIndex<int>(j)*stride_j + convertIndex<int>(i));
      }

      inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
        int linear = convertIndex<int>(lin);
        int _l = linear / (size_k*size_j*size_i);
        l = IdxL(_l);
        linear -= _l*(size_k*size_j*size_i);
        int _k = linear / (size_j*size_i);
        k = IdxK(_k);
        linear -= _k*(size_j*size_i);
        int _j = linear / (size_i);
        j = IdxJ(_j);
        linear -= _j*(size_i);
        i = IdxI(linear);
      }
    };



  
#endif

