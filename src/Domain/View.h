//AUTOGENERATED BY genView.py
  
#ifndef __DOMAIN_VIEW_H__
#define __DOMAIN_VIEW_H__

#include "Layout.h"


    template<typename T, typename L>
    struct View1d {
        inline View1d(T *data_ptr, int ni);
        inline T &operator()(int i) const;

        Layout1d<L> const layout;
        T *data;
    };

    template<typename T, typename L>
    struct View2d {
        inline View2d(T *data_ptr, int ni, int nj);
        inline T &operator()(int i, int j) const;

        Layout2d<L> const layout;
        T *data;
    };

    template<typename T, typename L, typename IdxI=int, typename IdxJ=int, typename IdxK=int>
    struct View3d {
      typedef IdxI IndexI;
      typedef IdxJ IndexJ;
      typedef IdxK IndexK;

      inline View3d(T *data_ptr, int ni, int nj, int nk):
        layout(ni, nj, nk),
        data(data_ptr)
      {
      }
      inline T &operator()(IdxI i, IdxJ j, IdxK k) const{
        return(data[ layout(i, j, k) ]);
      }

      // NOT DONE: perhaps this should get a Layout type as parameter, instead of a permutation

      Layout3d<L> const layout;
      T *data;
    };

    template<typename T, typename L>
    struct View4d {
        inline View4d(T *data_ptr, int ni, int nj, int nk, int nl);
        inline T &operator()(int i, int j, int k, int l) const;

        Layout4d<L> const layout;
        T *data;
    };


/******************************************************************
 *  Implementation for View1D
 ******************************************************************/

      template<typename T, typename L>
      inline View1d<T,L>::View1d(T *data_ptr, int ni):
        layout(ni),
        data(data_ptr)
      {
      }

      template<typename T, typename L>
      inline T &View1d<T,L>::operator()(int i) const {
        return(data[layout(i)]);
      }


/******************************************************************
 *  Implementation for View2D
 ******************************************************************/

      template<typename T, typename L>
      inline View2d<T,L>::View2d(T *data_ptr, int ni, int nj):
        layout(ni, nj),
        data(data_ptr)
      {
      }

      template<typename T, typename L>
      inline T &View2d<T,L>::operator()(int i, int j) const {
        return(data[layout(i, j)]);
      }


/******************************************************************
 *  Implementation for View3D
 ******************************************************************/



/******************************************************************
 *  Implementation for View4D
 ******************************************************************/

      template<typename T, typename L>
      inline View4d<T,L>::View4d(T *data_ptr, int ni, int nj, int nk, int nl):
        layout(ni, nj, nk, nl),
        data(data_ptr)
      {
      }

      template<typename T, typename L>
      inline T &View4d<T,L>::operator()(int i, int j, int k, int l) const {
        return(data[layout(i, j, k, l)]);
      }


  
#endif

