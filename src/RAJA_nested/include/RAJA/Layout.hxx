//AUTOGENERATED BY genLayout.py
  
#ifndef RAJA_LAYOUT_HXX__
#define RAJA_LAYOUT_HXX__

#include <RAJA/IndexValue.hxx>

namespace RAJA {


struct PERM_I {};
struct PERM_IJ {};
struct PERM_JI {};
struct PERM_IJK {};
struct PERM_IKJ {};
struct PERM_JIK {};
struct PERM_JKI {};
struct PERM_KIJ {};
struct PERM_KJI {};
struct PERM_IJKL {};
struct PERM_IJLK {};
struct PERM_IKJL {};
struct PERM_IKLJ {};
struct PERM_ILJK {};
struct PERM_ILKJ {};
struct PERM_JIKL {};
struct PERM_JILK {};
struct PERM_JKIL {};
struct PERM_JKLI {};
struct PERM_JLIK {};
struct PERM_JLKI {};
struct PERM_KIJL {};
struct PERM_KILJ {};
struct PERM_KJIL {};
struct PERM_KJLI {};
struct PERM_KLIJ {};
struct PERM_KLJI {};
struct PERM_LIJK {};
struct PERM_LIKJ {};
struct PERM_LJIK {};
struct PERM_LJKI {};
struct PERM_LKIJ {};
struct PERM_LKJI {};

template<typename Perm, typename IdxI=Index_type, typename IdxLin=Index_type>
struct Layout1d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxLin=Index_type>
struct Layout2d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxLin=Index_type>
struct Layout3d {};

template<typename Perm, typename IdxI=Index_type, typename IdxJ=Index_type, typename IdxK=Index_type, typename IdxL=Index_type, typename IdxLin=Index_type>
struct Layout4d {};


/******************************************************************
 *  Implementation for Layout1D
 ******************************************************************/

template<typename IdxI, typename IdxLin>
struct Layout1d<PERM_I, IdxI, IdxLin> {
  typedef PERM_I Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;

  Index_type const size_i;

  Index_type const stride_i;

  inline Layout1d(Index_type ni):
    size_i(ni), stride_i(1)
  {}

  inline IdxLin operator()(IdxI i) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i) const {
    Index_type linear = convertIndex<Index_type>(lin);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout2D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxLin>
struct Layout2d<PERM_IJ, IdxI, IdxJ, IdxLin> {
  typedef PERM_IJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  inline Layout2d(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(nj), stride_j(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxLin>
struct Layout2d<PERM_JI, IdxI, IdxJ, IdxLin> {
  typedef PERM_JI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;

  Index_type const size_i;
  Index_type const size_j;

  Index_type const stride_i;
  Index_type const stride_j;

  inline Layout2d(Index_type ni, Index_type nj):
    size_i(ni), size_j(nj), stride_i(1), stride_j(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout3D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_IJK, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_IJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj*nk), stride_j(nk), stride_k(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_IKJ, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_IKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk*nj), stride_j(1), stride_k(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_JIK, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_JIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nk), stride_j(ni*nk), stride_k(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_JKI, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_JKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(nk*ni), stride_k(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_KIJ, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_KIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(nj), stride_j(1), stride_k(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxLin>
struct Layout3d<PERM_KJI, IdxI, IdxJ, IdxK, IdxLin> {
  typedef PERM_KJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;

  inline Layout3d(Index_type ni, Index_type nj, Index_type nk):
    size_i(ni), size_j(nj), size_k(nk), stride_i(1), stride_j(ni), stride_k(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};



/******************************************************************
 *  Implementation for Layout4D
 ******************************************************************/

template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IJKL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IJKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk*nl), stride_j(nk*nl), stride_k(nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k*size_l);
    Index_type _j = linear / (size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IJLK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IJLK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl*nk), stride_j(nl*nk), stride_k(1), stride_l(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_j*size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l*size_k);
    Index_type _j = linear / (size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IKJL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IKJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj*nl), stride_j(nl), stride_k(nj*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j*size_l);
    Index_type _k = linear / (size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_IKLJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_IKLJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl*nj), stride_j(1), stride_k(nl*nj), stride_l(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_k*size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l*size_j);
    Index_type _k = linear / (size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_ILJK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_ILJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj*nk), stride_j(nk), stride_k(1), stride_l(nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j*size_k);
    Index_type _l = linear / (size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_ILKJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_ILKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk*nj), stride_j(1), stride_k(nj), stride_l(nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _i = linear / (size_l*size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k*size_j);
    Index_type _l = linear / (size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JIKL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JIKL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nl), stride_j(ni*nk*nl), stride_k(nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_k*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k*size_l);
    Index_type _i = linear / (size_k*size_l);
    i = IdxI(_i);
    linear -= _i*(size_k*size_l);
    Index_type _k = linear / (size_l);
    k = IdxK(_k);
    linear -= _k*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JILK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JILK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nk), stride_j(ni*nl*nk), stride_k(1), stride_l(nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_i*size_l*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l*size_k);
    Index_type _i = linear / (size_l*size_k);
    i = IdxI(_i);
    linear -= _i*(size_l*size_k);
    Index_type _l = linear / (size_k);
    l = IdxL(_l);
    linear -= _l*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JKIL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JKIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(nk*ni*nl), stride_k(ni*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i*size_l);
    Index_type _k = linear / (size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JKLI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JKLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*nl*ni), stride_k(nl*ni), stride_l(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_k*size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_l*size_i);
    Index_type _k = linear / (size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JLIK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JLIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(nl*ni*nk), stride_k(1), stride_l(ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i*size_k);
    Index_type _l = linear / (size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_JLKI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_JLKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*nk*ni), stride_k(ni), stride_l(nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _j = linear / (size_l*size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_k*size_i);
    Index_type _l = linear / (size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KIJL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KIJL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nl), stride_j(nl), stride_k(ni*nj*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_j*size_l);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j*size_l);
    Index_type _i = linear / (size_j*size_l);
    i = IdxI(_i);
    linear -= _i*(size_j*size_l);
    Index_type _j = linear / (size_l);
    j = IdxJ(_j);
    linear -= _j*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KILJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KILJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl*nj), stride_j(1), stride_k(ni*nl*nj), stride_l(nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_i*size_l*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_l*size_j);
    Index_type _i = linear / (size_l*size_j);
    i = IdxI(_i);
    linear -= _i*(size_l*size_j);
    Index_type _l = linear / (size_j);
    l = IdxL(_l);
    linear -= _l*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KJIL, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KJIL Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nl), stride_j(ni*nl), stride_k(nj*ni*nl), stride_l(1)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(l));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_i*size_l);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i*size_l);
    Index_type _j = linear / (size_i*size_l);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_l);
    Index_type _i = linear / (size_l);
    i = IdxI(_i);
    linear -= _i*(size_l);
    l = IdxL(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KJLI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KJLI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nl*ni), stride_k(nj*nl*ni), stride_l(ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_j*size_l*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_l*size_i);
    Index_type _j = linear / (size_l*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_l*size_i);
    Index_type _l = linear / (size_i);
    l = IdxL(_l);
    linear -= _l*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KLIJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KLIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(nl*ni*nj), stride_l(ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_l*size_i*size_j);
    Index_type _l = linear / (size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_KLJI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_KLJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nl*nj*ni), stride_l(nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _k = linear / (size_l*size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_l*size_j*size_i);
    Index_type _l = linear / (size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LIJK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LIJK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj*nk), stride_j(nk), stride_k(1), stride_l(ni*nj*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_j*size_k);
    l = IdxL(_l);
    linear -= _l*(size_i*size_j*size_k);
    Index_type _i = linear / (size_j*size_k);
    i = IdxI(_i);
    linear -= _i*(size_j*size_k);
    Index_type _j = linear / (size_k);
    j = IdxJ(_j);
    linear -= _j*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LIKJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LIKJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk*nj), stride_j(1), stride_k(nj), stride_l(ni*nk*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_i*size_k*size_j);
    l = IdxL(_l);
    linear -= _l*(size_i*size_k*size_j);
    Index_type _i = linear / (size_k*size_j);
    i = IdxI(_i);
    linear -= _i*(size_k*size_j);
    Index_type _k = linear / (size_j);
    k = IdxK(_k);
    linear -= _k*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LJIK, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LJIK Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nk), stride_j(ni*nk), stride_k(1), stride_l(nj*ni*nk)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(k));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_i*size_k);
    l = IdxL(_l);
    linear -= _l*(size_j*size_i*size_k);
    Index_type _j = linear / (size_i*size_k);
    j = IdxJ(_j);
    linear -= _j*(size_i*size_k);
    Index_type _i = linear / (size_k);
    i = IdxI(_i);
    linear -= _i*(size_k);
    k = IdxK(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LJKI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LJKI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(nk*ni), stride_k(ni), stride_l(nj*nk*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_j*size_k*size_i);
    l = IdxL(_l);
    linear -= _l*(size_j*size_k*size_i);
    Index_type _j = linear / (size_k*size_i);
    j = IdxJ(_j);
    linear -= _j*(size_k*size_i);
    Index_type _k = linear / (size_i);
    k = IdxK(_k);
    linear -= _k*(size_i);
    i = IdxI(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LKIJ, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LKIJ Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(nj), stride_j(1), stride_k(ni*nj), stride_l(nk*ni*nj)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(i)*stride_i + convertIndex<Index_type>(j));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_i*size_j);
    l = IdxL(_l);
    linear -= _l*(size_k*size_i*size_j);
    Index_type _k = linear / (size_i*size_j);
    k = IdxK(_k);
    linear -= _k*(size_i*size_j);
    Index_type _i = linear / (size_j);
    i = IdxI(_i);
    linear -= _i*(size_j);
    j = IdxJ(linear);
  }
};


template<typename IdxI, typename IdxJ, typename IdxK, typename IdxL, typename IdxLin>
struct Layout4d<PERM_LKJI, IdxI, IdxJ, IdxK, IdxL, IdxLin> {
  typedef PERM_LKJI Permutation;
  typedef IdxLin IndexLinear;
  typedef IdxI IndexI;
  typedef IdxJ IndexJ;
  typedef IdxK IndexK;
  typedef IdxL IndexL;

  Index_type const size_i;
  Index_type const size_j;
  Index_type const size_k;
  Index_type const size_l;

  Index_type const stride_i;
  Index_type const stride_j;
  Index_type const stride_k;
  Index_type const stride_l;

  inline Layout4d(Index_type ni, Index_type nj, Index_type nk, Index_type nl):
    size_i(ni), size_j(nj), size_k(nk), size_l(nl), stride_i(1), stride_j(ni), stride_k(nj*ni), stride_l(nk*nj*ni)
  {}

  inline IdxLin operator()(IdxI i, IdxJ j, IdxK k, IdxL l) const {
    return convertIndex<IdxLin>(convertIndex<Index_type>(l)*stride_l + convertIndex<Index_type>(k)*stride_k + convertIndex<Index_type>(j)*stride_j + convertIndex<Index_type>(i));
  }

  inline void toIndices(IdxLin lin, IdxI &i, IdxJ &j, IdxK &k, IdxL &l) const {
    Index_type linear = convertIndex<Index_type>(lin);
    Index_type _l = linear / (size_k*size_j*size_i);
    l = IdxL(_l);
    linear -= _l*(size_k*size_j*size_i);
    Index_type _k = linear / (size_j*size_i);
    k = IdxK(_k);
    linear -= _k*(size_j*size_i);
    Index_type _j = linear / (size_i);
    j = IdxJ(_j);
    linear -= _j*(size_i);
    i = IdxI(linear);
  }
};




} // namespace RAJA

#endif

